<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <title>ÿ≠ÿßŸÖŸä ÿßŸÑŸÖÿ¨ÿ±ÿ© - Space Defender</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            touch-action: none;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0015 0%, #1a0033 50%, #0a0015 100%);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        canvas {
            display: block;
            background: #000;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        
        #ui {
            position: absolute;
            top: 50px;
            left: 10px;
            right: 10px;
            color: white;
            font-size: 13px;
            display: none; /* Hidden initially */
            justify-content: space-between;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            pointer-events: none;
            z-index: 10;
        }
        
        @media (min-width: 600px) {
            #ui {
                font-size: 18px;
                top: 70px;
                left: 30px;
                right: 30px;
            }
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px 20px;
            border-radius: 20px;
            text-align: center;
            display: none;
            border: 3px solid #00ffff;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.6);
            max-width: 90%;
            z-index: 100;
        }
        
        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px 30px;
            border-radius: 20px;
            text-align: center;
            border: 3px solid #ff00ff;
            box-shadow: 0 0 40px rgba(255, 0, 255, 0.6);
            max-width: 90%;
            z-index: 100;
        }
        
        #startScreen h1 {
            color: #ff00ff;
            font-size: 32px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
        }
        
        #bonusScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px 30px;
            border-radius: 20px;
            text-align: center;
            display: none;
            border: 3px solid #ffff00;
            box-shadow: 0 0 40px rgba(255, 255, 0, 0.6);
            max-width: 90%;
            z-index: 100;
        }
        
        #bonusScreen h2 {
            color: #ffff00;
            font-size: 28px;
            margin-bottom: 15px;
            text-shadow: 0 0 20px rgba(255, 255, 0, 0.8);
        }
        
        #bonusScreen p {
            color: #00ffff;
            font-size: 18px;
            margin: 10px 0;
        }
        
        .pause-btn {
            position: absolute;
            top: 10px;
            right: 10px; /* Changed from left to right */
            background: rgba(255, 0, 102, 0.3);
            border: 2px solid rgba(255, 0, 102, 0.7);
            color: #ff0066;
            padding: 8px 15px;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            z-index: 10;
            display: none; /* Hidden initially */
        }
        
        @media (min-width: 600px) {
            .pause-btn {
                top: 30px;
                right: 30px; /* Changed from left to right */
                padding: 10px 20px;
                font-size: 18px;
            }
            
            #startScreen h1 {
                font-size: 42px;
            }
            
            #bonusScreen h2 {
                font-size: 36px;
            }
        }
        
        #gameOver h2 {
            color: #ff0066;
            font-size: 28px;
            margin-bottom: 15px;
            text-shadow: 0 0 20px rgba(255, 0, 102, 0.8);
        }
        
        #gameOver p {
            color: #00ffff;
            font-size: 18px;
            margin: 8px 0;
        }
        
        @media (min-width: 600px) {
            #gameOver {
                padding: 40px;
            }
            #gameOver h2 {
                font-size: 36px;
                margin-bottom: 20px;
            }
            #gameOver p {
                font-size: 24px;
                margin: 10px 0;
            }
        }
        
        #restartBtn {
            background: linear-gradient(135deg, #ff0066, #9900ff);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(255, 0, 102, 0.5);
        }
        
        #restartBtn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 0, 102, 0.8);
        }
        
        .powerup-indicator {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffff00;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 15px;
            border-radius: 10px;
            display: none;
            border: 2px solid #ffff00;
            z-index: 10;
            white-space: nowrap;
        }
        
        .powerup-indicators-container {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            display: none; /* Hidden initially */
            gap: 10px;
            z-index: 10;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90%;
        }
        
        /* Stored powerups container */
        .stored-powerups-container {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: none; /* Hidden initially */
            flex-direction: row;
            gap: 10px;
            z-index: 10;
            align-items: center;
            justify-content: center;
        }
        
        .stored-powerup-badge {
            width: 45px;
            height: 45px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ffff00;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            cursor: pointer;
            transition: all 0.2s;
            pointer-events: auto;
        }
        
        .stored-powerup-badge:active {
            transform: scale(0.9);
            box-shadow: 0 0 20px currentColor;
        }
        
        .activate-all-btn {
            background: linear-gradient(135deg, #ff0066, #9900ff);
            color: white;
            border: none;
            padding: 8px 15px;
            font-size: 14px;
            border-radius: 8px;
            cursor: pointer;
            white-space: nowrap;
            box-shadow: 0 0 15px rgba(255, 0, 102, 0.5);
            transition: all 0.2s;
            pointer-events: auto;
            display: none; /* Hidden initially - shown when game starts */
        }
        
        .activate-all-btn:active {
            transform: scale(0.95);
            box-shadow: 0 0 25px rgba(255, 0, 102, 0.8);
        }
        
        @media (min-width: 600px) {
            .stored-powerup-badge {
                width: 50px;
                height: 50px;
                font-size: 24px;
            }
            
            .activate-all-btn {
                padding: 10px 20px;
                font-size: 16px;
            }
        }
        
        .powerup-badge {
            color: #ffff00;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 15px;
            border-radius: 10px;
            border: 2px solid #ffff00;
            white-space: nowrap;
        }
        
        @media (min-width: 600px) {
            .powerup-indicator {
                top: 100px;
                font-size: 16px;
                padding: 10px 20px;
            }
            
            .powerup-indicators-container {
                top: 140px;
            }
            
            .powerup-badge {
                font-size: 16px;
                padding: 10px 20px;
            }
        }
        
        #instructions {
            display: none;
        }
        
        @media (min-width: 600px) {
            
            #instructions {
                display: block;
                position: absolute;
                bottom: 30px;
                right: 30px;
                color: #aaa;
                font-size: 14px;
                text-align: left;
                background: rgba(0, 0, 0, 0.7);
                padding: 15px;
                border-radius: 10px;
            }
        }
        
        /* Mobile Controls */
        .mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: none; /* Hidden initially */
            justify-content: space-between;
            padding: 0 15px;
            z-index: 10;
            pointer-events: none;
        }
        
        .control-group {
            display: flex;
            gap: 12px;
            pointer-events: auto;
        }
        
        .control-btn {
            width: 85px;
            height: 85px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.3);
            border: 4px solid rgba(0, 255, 255, 0.7);
            color: #00ffff;
            font-size: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            transition: all 0.1s;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.5);
            font-weight: bold;
            touch-action: manipulation;
        }
        
        .control-btn:active {
            background: rgba(0, 255, 255, 0.6);
            transform: scale(0.92);
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.8);
            border-color: #00ffff;
        }
        
        .special-btn {
            background: rgba(255, 0, 102, 0.3);
            border-color: rgba(255, 0, 102, 0.7);
            color: #ff0066;
            box-shadow: 0 0 25px rgba(255, 0, 102, 0.5);
        }
        
        .special-btn:active {
            background: rgba(255, 0, 102, 0.6);
            box-shadow: 0 0 40px rgba(255, 0, 102, 0.8);
            border-color: #ff0066;
        }
        
        @media (min-width: 600px) {
            .mobile-controls {
                display: none;
            }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui">
            <div>
                <div>ÿßŸÑŸÜŸÇÿßÿ∑: <span id="score">0</span></div>
                <div>üí∞ <span id="coins">0</span></div>
                <div>ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: <span id="level">1</span></div>
            </div>
            <div style="text-align: left;">
                <div>ÿßŸÑÿµÿ≠ÿ©: <span id="health">100</span>%</div>
                <div>ÿßŸÑÿ∑ÿßŸÇÿ©: <span id="energy">100</span>%</div>
            </div>
        </div>
        <button class="pause-btn" id="pauseBtn">‚è∏ ÿ•ŸäŸÇÿßŸÅ</button>
        
        <!-- Stored powerups (collected but not activated) -->
        <div class="stored-powerups-container" id="storedPowerupsContainer"></div>
        
        <div class="powerup-indicator" id="powerupIndicator"></div>
        <div class="powerup-indicators-container" id="powerupContainer"></div>
        <div id="instructions">
            WASD ÿ£Ÿà ÿßŸÑÿ£ÿ≥ŸáŸÖ ŸÑŸÑÿ™ÿ≠ŸÉŸÖ<br>
            ÿ•ÿ∑ŸÑÿßŸÇ ÿ™ŸÑŸÇÿßÿ¶Ÿä<br>
            Shift ŸÑŸÑŸÇŸàÿ© ÿßŸÑÿÆÿßÿµÿ©
        </div>
        
        <!-- Mobile Controls -->
        <div class="mobile-controls">
            <div class="control-group">
                <button class="activate-all-btn" id="activateAllBtn">üéÅ ÿ™ŸÅÿπŸäŸÑ ÿßŸÑŸÉŸÑ</button>
                <button class="activate-all-btn" id="autoToggleBtn" style="background: linear-gradient(135deg, #00cc00, #006600);">
                    üîÑ ŸäÿØŸàŸä
                </button>
            </div>
            <div class="control-group">
                <div class="control-btn special-btn" id="specialBtn">‚ö°</div>
            </div>
        </div>
        
        <div id="startScreen">
            <h1>üöÄ ÿ≠ÿßŸÖŸä ÿßŸÑŸÖÿ¨ÿ±ÿ© üöÄ</h1>
            <p style="color: #aaa; margin: 20px 0;">ÿßÿ≠ŸÖŸê ÿßŸÑŸÖÿ¨ÿ±ÿ© ŸÖŸÜ ÿ∫ÿ≤Ÿà ÿßŸÑÿ£ÿπÿØÿßÿ°!</p>
            <button id="startBtn" class="control-btn" style="width: auto; padding: 15px 40px; margin-top: 20px;">ÿßÿ®ÿØÿ£ ÿßŸÑŸÑÿπÿ®</button>
        </div>
        
        <div id="bonusScreen">
            <h2>üéâ ŸÖŸÉÿßŸÅÿ£ÿ© ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ! üéâ</h2>
            <p id="bonusText">ŸàÿµŸÑÿ™ ŸÑŸÑŸÖÿ≥ÿ™ŸàŸâ <span id="bonusLevel">5</span>!</p>
            <p style="color: #ffff00;">+ <span id="bonusPoints">500</span> ŸÜŸÇÿ∑ÿ© ÿ•ÿ∂ÿßŸÅŸäÿ©!</p>
            <p style="color: #00ff00;">+ ÿµÿ≠ÿ© ŸÉÿßŸÖŸÑÿ©!</p>
            <button id="continueBtn" class="control-btn" style="width: auto; padding: 12px 35px; margin-top: 15px;">ŸÖÿ™ÿßÿ®ÿπÿ©</button>
        </div>
        
        <!-- Boss Rewards Screen -->
        <div id="bossRewardsScreen" style="display: none;">
            <h2>üèÜ Ÿáÿ≤ŸÖÿ™ ÿßŸÑÿ®Ÿàÿ≥! üèÜ</h2>
            <p style="color: #ffff00; font-size: 20px;">ÿßÿÆÿ™ÿ± ŸÖŸÉÿßŸÅÿ£ÿ™ŸÉ:</p>
            <div id="rewardOptions" style="display: flex; flex-direction: column; gap: 15px; margin-top: 20px;">
                <!-- Will be filled dynamically -->
            </div>
        </div>
        
        <div id="gameOver">
            <h2>ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©!</h2>
            <p>ŸÜŸÇÿßÿ∑ŸÉ ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ©: <span id="finalScore">0</span></p>
            <p>ÿ£ÿπŸÑŸâ ŸÜŸÇÿßÿ∑: <span id="highScore">0</span></p>
            <button id="restartBtn">ÿßŸÑÿπÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size to match window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Game state
        let gameRunning = false; // Start as false, waiting for user to press start
        let gamePaused = false;
        let levelTransition = false;
        let levelTransitionTimer = 0;
        let bossActive = false;
        let boss = null;
        let score = 0;
        let coins = 0; // New currency system
        let level = 1;
        let health = 100;
        let energy = 100;
        let highScore = localStorage.getItem('highScore') || 0;
        let enemyKills = 0; // Track enemy kills for level progression
        let livesRemaining = 3; // Lives system
        
        // Stored powerups system (collected but not activated)
        let storedPowerups = [];
        let maxStoredPowerups = 4;
        let autoActivatePowerups = false; // Toggle for auto-activate
        let powerupCounts = {}; // Track stacked powerups
        
        // Currency and shop system
        let allies = []; // Additional player characters
        let maxAllies = 4; // Maximum 4 allies
        
        // Player
        const player = {
            x: canvas.width / 2,
            y: canvas.height - 80,
            width: 40,
            height: 40,
            speed: 8, // Increased speed for smoother control
            dx: 0,
            dy: 0, // For vertical movement
            color: '#00ffff',
            trail: []
        };
        
        // Arrays
        let bullets = [];
        let enemies = [];
        let particles = [];
        let powerups = [];
        let stars = [];
        
        // Power-up state
        let rapidFire = false;
        let rapidFireTimer = 0;
        let shield = false;
        let shieldTimer = 0;
        
        // Powerup inventory - collected but not activated
        let powerupInventory = {
            rapidfire: 0,
            shield: 0,
            health: 0,
            energy: 0
        };
        
        // Input
        const keys = {};
        
        // Mobile controls state
        let shooting = true; // Always shooting automatically
        let touchActive = false;
        let touchX = 0;
        let touchY = 0; // Track both X and Y for full movement
        
        // Initialize stars
        for (let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2,
                speed: Math.random() * 2 + 1
            });
        }
        
        // Mobile button handlers
        const specialBtn = document.getElementById('specialBtn');
        
        // Canvas touch controls - move player in all directions with finger
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchActive = true;
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchX = touch.clientX - rect.left;
            touchY = touch.clientY - rect.top;
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (touchActive) {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                touchX = touch.clientX - rect.left;
                touchY = touch.clientY - rect.top;
            }
        }, { passive: false });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchActive = false;
        }, { passive: false });
        
        // Prevent scrolling on touch
        document.body.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
        
        specialBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (energy >= 30 && gameRunning) {
                useSpecialPower();
            }
        }, { passive: false });
        
        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            if ((e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w') && gameRunning) {
                e.preventDefault();
                if (!shootInterval) {
                    startShooting();
                }
            }
            
            if (e.key === 'Shift' && energy >= 30 && gameRunning) {
                useSpecialPower();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
            
            if (e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w') {
                stopShooting();
            }
        });
        
        document.getElementById('restartBtn').addEventListener('click', restartGame);
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('pauseBtn').addEventListener('click', togglePause);
        document.getElementById('continueBtn').addEventListener('click', continueAfterBonus);
        document.getElementById('activateAllBtn').addEventListener('click', useAllPowerups);
        document.getElementById('autoToggleBtn').addEventListener('click', () => {
            autoActivatePowerups = !autoActivatePowerups;
            const btn = document.getElementById('autoToggleBtn');
            if (autoActivatePowerups) {
                btn.textContent = '‚ö° ÿ™ŸÑŸÇÿßÿ¶Ÿä';
                btn.style.background = 'linear-gradient(135deg, #ffaa00, #ff6600)';
            } else {
                btn.textContent = 'üîÑ ŸäÿØŸàŸä';
                btn.style.background = 'linear-gradient(135deg, #00cc00, #006600)';
            }
        });
        
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('ui').style.display = 'flex';
            document.getElementById('pauseBtn').style.display = 'block';
            document.getElementById('activateAllBtn').style.display = 'block';
            document.getElementById('autoToggleBtn').style.display = 'block';
            document.querySelector('.mobile-controls').style.display = 'flex';
            document.querySelector('.stored-powerups-container').style.display = 'flex';
            document.querySelector('.powerup-indicators-container').style.display = 'flex';
            gameRunning = true;
            shooting = true;
            startShooting(); // Start automatic shooting
            gameLoop();
        }
        
        function togglePause() {
            gamePaused = !gamePaused;
            const btn = document.getElementById('pauseBtn');
            if (gamePaused) {
                btn.textContent = '‚ñ∂ ÿ™ÿ¥ÿ∫ŸäŸÑ';
                stopShooting();
            } else {
                btn.textContent = '‚è∏ ÿ•ŸäŸÇÿßŸÅ';
            }
        }
        
        function continueAfterBonus() {
            document.getElementById('bonusScreen').style.display = 'none';
            levelTransition = false;
            gameRunning = true;
        }
        
        function shoot() {
            // Check burst limit
            if (burstCooldown) return;
            
            bulletsInBurst++;
            
            if (rapidFire) {
                bullets.push({
                    x: player.x - 10,
                    y: player.y,
                    width: 6,
                    height: 18,
                    speed: 12,
                    color: '#ff00ff'
                });
                bullets.push({
                    x: player.x + 10,
                    y: player.y,
                    width: 6,
                    height: 18,
                    speed: 12,
                    color: '#ff00ff'
                });
            } else {
                bullets.push({
                    x: player.x,
                    y: player.y,
                    width: 6,
                    height: 18,
                    speed: 12,
                    color: '#ffff00'
                });
            }
            
            // Check if burst limit reached
            if (bulletsInBurst >= maxBulletsInBurst) {
                burstCooldown = true;
                // Reset after cooldown
                setTimeout(() => {
                    bulletsInBurst = 0;
                    burstCooldown = false;
                }, 500); // 0.5 second cooldown
            }
        }
        
        function useSpecialPower() {
            energy -= 30;
            
            // Create circular blast
            for (let angle = 0; angle < Math.PI * 2; angle += 0.3) {
                bullets.push({
                    x: player.x,
                    y: player.y,
                    width: 6,
                    height: 6,
                    speed: 8,
                    dx: Math.cos(angle) * 8,
                    dy: Math.sin(angle) * 8,
                    color: '#ff0066',
                    special: true
                });
            }
            
            // Create particles
            for (let i = 0; i < 30; i++) {
                particles.push({
                    x: player.x,
                    y: player.y,
                    dx: (Math.random() - 0.5) * 8,
                    dy: (Math.random() - 0.5) * 8,
                    size: Math.random() * 4 + 2,
                    color: `hsl(${Math.random() * 60 + 300}, 100%, 50%)`,
                    life: 30
                });
            }
        }
        
        function spawnBoss() {
            bossActive = true;
            boss = {
                x: canvas.width / 2,
                y: -100,
                width: 120,
                height: 120,
                speed: 1,
                targetY: canvas.height * 0.25, // Stop at 25% from top
                health: 30, // Reduced health so it drops 4 powerups max
                maxHealth: 30,
                shootTimer: 0,
                moveDirection: 1,
                moveTimer: 0,
                phase: 1,
                color: '#ff0066',
                entering: true,
                powerupsDropped: 0
            };
            
            // Show boss warning
            const container = document.getElementById('powerupContainer');
            const bossBadge = document.createElement('div');
            bossBadge.className = 'powerup-badge';
            bossBadge.style.borderColor = '#ff0066';
            bossBadge.style.color = '#ff0066';
            bossBadge.style.fontSize = '20px';
            bossBadge.style.animation = 'pulse 0.5s infinite';
            bossBadge.textContent = '‚ö†Ô∏è ÿ™ÿ≠ÿ∞Ÿäÿ±! ÿßŸÑÿ®Ÿàÿ≥ ŸÇÿßÿØŸÖ! ‚ö†Ô∏è';
            container.appendChild(bossBadge);
            
            setTimeout(() => {
                bossBadge.remove();
            }, 3000);
        }
        
        
        function updateBoss() {
            if (!boss) return;
            
            // Move boss down to target position
            if (boss.entering) {
                if (boss.y < boss.targetY) {
                    boss.y += boss.speed;
                } else {
                    boss.entering = false;
                    boss.directionTimer = 0;
                    boss.currentDirection = { x: 1, y: 0.5 }; // Start moving diagonally
                }
            } else {
                // Move in all directions (diagonal pattern)
                boss.directionTimer++;
                
                // Change direction every 60 frames
                if (boss.directionTimer > 60) {
                    const directions = [
                        { x: 1, y: 0.5 },   // Right-down
                        { x: -1, y: 0.5 },  // Left-down
                        { x: 1, y: -0.5 },  // Right-up
                        { x: -1, y: -0.5 }, // Left-up
                        { x: 1, y: 0 },     // Right
                        { x: -1, y: 0 },    // Left
                    ];
                    boss.currentDirection = directions[Math.floor(Math.random() * directions.length)];
                    boss.directionTimer = 0;
                }
                
                boss.x += boss.currentDirection.x * 2.5;
                boss.y += boss.currentDirection.y * 1.5;
                
                // Keep boss in bounds
                const margin = 20;
                if (boss.x < boss.width / 2 + margin) {
                    boss.x = boss.width / 2 + margin;
                    boss.currentDirection.x *= -1; // Bounce
                }
                if (boss.x > canvas.width - boss.width / 2 - margin) {
                    boss.x = canvas.width - boss.width / 2 - margin;
                    boss.currentDirection.x *= -1; // Bounce
                }
                if (boss.y < boss.targetY - 30) {
                    boss.y = boss.targetY - 30;
                    boss.currentDirection.y *= -1; // Bounce
                }
                if (boss.y > boss.targetY + 80) {
                    boss.y = boss.targetY + 80;
                    boss.currentDirection.y *= -1; // Bounce
                }
            }
            
            // Boss shooting - only when not entering
            if (!boss.entering) {
                boss.shootTimer++;
                if (boss.shootTimer > 50) {
                    // Shoot 3 bullets in spread pattern
                    for (let i = -1; i <= 1; i++) {
                        bullets.push({
                            x: boss.x + i * 35,
                            y: boss.y + boss.height / 2,
                            width: 6,
                            height: 12,
                            speed: -4,
                            color: '#ff0066',
                            enemy: true
                        });
                    }
                    boss.shootTimer = 0;
                }
            }
            
            // Phase 2: faster and more aggressive at 50% health
            if (boss.health < boss.maxHealth / 2 && boss.phase === 1) {
                boss.phase = 2;
                boss.shootTimer = -20;
            }
            
            // Phase 2 behavior
            if (boss.phase === 2 && boss.shootTimer % 25 === 0 && boss.shootTimer > 0) {
                // Extra shots in phase 2
                bullets.push({
                    x: boss.x,
                    y: boss.y + boss.height / 2,
                    width: 8,
                    height: 14,
                    speed: -5,
                    color: '#ff00ff',
                    enemy: true
                });
            }
        }
        
        function drawBoss() {
            if (!boss) return;
            
            ctx.save();
            ctx.translate(boss.x, boss.y);
            
            // Pulsing glow effect
            const glowSize = boss.phase === 2 ? 40 : 30;
            ctx.shadowBlur = glowSize;
            ctx.shadowColor = boss.color;
            
            // Main body - large triangle
            ctx.fillStyle = boss.color;
            ctx.beginPath();
            ctx.moveTo(0, boss.height / 2); // Bottom
            ctx.lineTo(-boss.width / 2, -boss.height / 2); // Top left
            ctx.lineTo(boss.width / 2, -boss.height / 2); // Top right
            ctx.closePath();
            ctx.fill();
            
            // Wings
            ctx.fillStyle = boss.phase === 2 ? '#ff00ff' : boss.color;
            ctx.globalAlpha = 0.8;
            
            // Left wing
            ctx.beginPath();
            ctx.moveTo(-boss.width / 2, 0);
            ctx.lineTo(-boss.width * 0.9, -boss.height / 4);
            ctx.lineTo(-boss.width * 0.9, boss.height / 4);
            ctx.closePath();
            ctx.fill();
            
            // Right wing
            ctx.beginPath();
            ctx.moveTo(boss.width / 2, 0);
            ctx.lineTo(boss.width * 0.9, -boss.height / 4);
            ctx.lineTo(boss.width * 0.9, boss.height / 4);
            ctx.closePath();
            ctx.fill();
            
            ctx.globalAlpha = 1;
            
            // Cockpit - glowing
            ctx.fillStyle = boss.phase === 2 ? '#ffff00' : '#ffffff';
            ctx.beginPath();
            ctx.arc(0, 0, boss.width / 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Engine flames
            for (let i = 0; i < 3; i++) {
                ctx.fillStyle = i % 2 === 0 ? '#ff6600' : '#ffff00';
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                const flameOffset = (i - 1) * 20;
                ctx.arc(flameOffset, boss.height / 2, boss.width / 6, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.globalAlpha = 1;
            ctx.restore();
            
            // Health bar
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(boss.x - 60, boss.y - boss.height / 2 - 20, 120, 10);
            
            const healthPercent = boss.health / boss.maxHealth;
            ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.25 ? '#ffff00' : '#ff0000';
            ctx.fillRect(boss.x - 60, boss.y - boss.height / 2 - 20, 120 * healthPercent, 10);
            
            // Boss name
            ctx.fillStyle = '#ff0066';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ff0066';
            ctx.fillText('üëë ÿßŸÑÿ®Ÿàÿ≥ üëë', boss.x, boss.y - boss.height / 2 - 30);
            
            ctx.shadowBlur = 0;
        }
        
        
        function spawnEnemy() {
            const types = ['basic', 'fast', 'tank', 'shooter'];
            const type = types[Math.floor(Math.random() * Math.min(types.length, 1 + level / 3))];
            
            const enemy = {
                x: Math.random() * (canvas.width - 40),
                y: -40,
                type: type
            };
            
            switch(type) {
                case 'basic':
                    enemy.width = 30;
                    enemy.height = 30;
                    enemy.speed = 0.3 * Math.pow(1.1, level); // 10% faster each level
                    enemy.health = 1;
                    enemy.color = '#ff0000';
                    enemy.points = 10;
                    break;
                case 'fast':
                    enemy.width = 25;
                    enemy.height = 25;
                    enemy.speed = 0.5 * Math.pow(1.1, level); // 10% faster each level
                    enemy.health = 1;
                    enemy.color = '#ff9900';
                    enemy.points = 20;
                    break;
                case 'tank':
                    enemy.width = 45;
                    enemy.height = 45;
                    enemy.speed = 0.2 * Math.pow(1.1, level); // 10% faster each level
                    enemy.health = 3;
                    enemy.color = '#9900ff';
                    enemy.points = 50;
                    break;
                case 'shooter':
                    enemy.width = 35;
                    enemy.height = 35;
                    enemy.speed = 0.4 * Math.pow(1.1, level); // 10% faster each level
                    enemy.health = 2;
                    enemy.color = '#00ff00';
                    enemy.points = 30;
                    enemy.canShoot = true;
                    enemy.shootTimer = 0;
                    break;
            }
            
            enemies.push(enemy);
        }
        
        
        
        function spawnPowerup(x, y) {
            if (Math.random() < 0.3) {
                const types = ['rapidfire', 'shield', 'health', 'bullets'];
                powerups.push({
                    x: x,
                    y: y,
                    width: 20,
                    height: 20,
                    speed: 2,
                    type: types[Math.floor(Math.random() * types.length)],
                    lifetime: 300,
                    maxLifetime: 300
                });
            }
        }
        
        function updatePlayer() {
            player.dx = 0;
            player.dy = 0;
            
            // Touch control - follow finger in all directions
            if (touchActive) {
                const diffX = touchX - player.x;
                const diffY = touchY - player.y;
                
                // Smooth movement towards touch position (X axis)
                if (Math.abs(diffX) > 5) {
                    player.dx = Math.sign(diffX) * player.speed;
                } else {
                    player.x = touchX;
                }
                
                // Smooth movement towards touch position (Y axis)
                if (Math.abs(diffY) > 5) {
                    player.dy = Math.sign(diffY) * player.speed;
                } else {
                    player.y = touchY;
                }
            }
            // Desktop keyboard controls (WASD or arrows)
            else {
                if (keys['ArrowLeft'] || keys['a']) {
                    player.dx = -player.speed;
                }
                if (keys['ArrowRight'] || keys['d']) {
                    player.dx = player.speed;
                }
                if (keys['ArrowUp'] || keys['w']) {
                    player.dy = -player.speed;
                }
                if (keys['ArrowDown'] || keys['s']) {
                    player.dy = player.speed;
                }
            }
            
            player.x += player.dx;
            player.y += player.dy;
            
            // Boundaries
            // Horizontal: can reach full left and right
            const minX = player.width / 2;
            const maxX = canvas.width - player.width / 2;
            
            // Vertical: can't go above middle of screen
            const minY = canvas.height / 2; // Can't go above middle
            const maxY = canvas.height - player.height / 2 - 10; // Bottom boundary
            
            if (player.x < minX) player.x = minX;
            if (player.x > maxX) player.x = maxX;
            if (player.y < minY) player.y = minY;
            if (player.y > maxY) player.y = maxY;
            
            // Add trail
            player.trail.push({ x: player.x, y: player.y, life: 10 });
            if (player.trail.length > 15) player.trail.shift();
            
            // Energy regen
            if (energy < 100) energy += 0.1;
        }
        
        function updateBullets() {
            bullets = bullets.filter(bullet => {
                if (bullet.special) {
                    bullet.x += bullet.dx;
                    bullet.y += bullet.dy;
                } else if (bullet.homing && bullet.enemy) {
                    // Homing bullet (boss attack)
                    bullet.x += bullet.dx;
                    bullet.y += bullet.dy;
                } else {
                    bullet.y -= bullet.speed;
                }
                return bullet.y > -20 && bullet.y < canvas.height + 20 && bullet.x > 0 && bullet.x < canvas.width;
            });
        }
        
        function updateEnemies() {
            enemies.forEach(enemy => {
                enemy.y += enemy.speed;
                
                // Enemy shooting
                if (enemy.canShoot) {
                    enemy.shootTimer++;
                    if (enemy.shootTimer > 60) {
                        bullets.push({
                            x: enemy.x,
                            y: enemy.y + enemy.height,
                            width: 4,
                            height: 10,
                            speed: -5,
                            color: '#00ff00',
                            enemy: true
                        });
                        enemy.shootTimer = 0;
                    }
                }
            });
            
            enemies = enemies.filter(enemy => enemy.y < canvas.height + 50);
        }
        
        function updatePowerups() {
            powerups.forEach(powerup => {
                powerup.y += powerup.speed;
                powerup.lifetime--;
            });
            
            powerups = powerups.filter(powerup => powerup.y < canvas.height && powerup.lifetime > 0);
        }
        
        function updateParticles() {
            particles.forEach(particle => {
                particle.x += particle.dx;
                particle.y += particle.dy;
                particle.life--;
            });
            
            particles = particles.filter(p => p.life > 0);
        }
        
        function updateStars() {
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
        }
        
        function checkCollisions() {
            // Bullets vs boss
            if (boss && !boss.entering) {
                for (let bIndex = bullets.length - 1; bIndex >= 0; bIndex--) {
                    const bullet = bullets[bIndex];
                    if (bullet.enemy) continue;
                    
                    const distance = Math.sqrt(
                        Math.pow(bullet.x - boss.x, 2) + 
                        Math.pow(bullet.y - boss.y, 2)
                    );
                    
                    if (distance < boss.width / 2) {
                        boss.health -= 1;
                        bullets.splice(bIndex, 1);
                        
                        // Drop powerup every hit (max 4 total)
                        if (boss.powerupsDropped < 4) {
                            const types = ['rapidfire', 'shield', 'health', 'bullets'];
                            const type = types[boss.powerupsDropped]; // Drop in order
                            powerups.push({
                                x: boss.x + (Math.random() - 0.5) * 40,
                                y: boss.y,
                                width: 20,
                                height: 20,
                                speed: 2,
                                type: type,
                                lifetime: 300,
                                maxLifetime: 300
                            });
                            boss.powerupsDropped++;
                        }
                        
                        // Boss hit particles
                        for (let i = 0; i < 20; i++) {
                            particles.push({
                                x: boss.x,
                                y: boss.y,
                                dx: (Math.random() - 0.5) * 10,
                                dy: (Math.random() - 0.5) * 10,
                                size: Math.random() * 5 + 2,
                                color: boss.color,
                                life: 30
                            });
                        }
                        
                        // Boss defeated
                        if (boss.health <= 0) {
                            score += 1000; // Big bonus for defeating boss
                            
                            // Massive explosion
                            for (let i = 0; i < 100; i++) {
                                const angle = (Math.PI * 2 * i) / 100;
                                const speed = Math.random() * 8 + 4;
                                particles.push({
                                    x: boss.x,
                                    y: boss.y,
                                    dx: Math.cos(angle) * speed,
                                    dy: Math.sin(angle) * speed,
                                    size: Math.random() * 8 + 3,
                                    color: ['#ff0066', '#ffff00', '#ffffff'][Math.floor(Math.random() * 3)],
                                    life: 50
                                });
                            }
                            
                            // Reward player
                            health = 100;
                            energy = 100;
                            coins += 100; // Big coin reward for defeating boss
                            
                            bossActive = false;
                            boss = null;
                            
                            // Show boss rewards screen
                            showBossRewards();
                        }
                    }
                }
            }
            
            // Bullets vs enemies - improved collision with bullet edges
            for (let bIndex = bullets.length - 1; bIndex >= 0; bIndex--) {
                const bullet = bullets[bIndex];
                if (bullet.enemy) continue;
                
                for (let eIndex = enemies.length - 1; eIndex >= 0; eIndex--) {
                    const enemy = enemies[eIndex];
                    
                    // Check if any part of bullet touches enemy (including edges)
                    const bulletLeft = bullet.x - bullet.width / 2;
                    const bulletRight = bullet.x + bullet.width / 2;
                    const bulletTop = bullet.y - bullet.height / 2;
                    const bulletBottom = bullet.y + bullet.height / 2;
                    
                    const enemyLeft = enemy.x - enemy.width / 2;
                    const enemyRight = enemy.x + enemy.width / 2;
                    const enemyTop = enemy.y - enemy.height / 2;
                    const enemyBottom = enemy.y + enemy.height / 2;
                    
                    // Better collision detection - any overlap
                    if (bulletRight > enemyLeft &&
                        bulletLeft < enemyRight &&
                        bulletBottom > enemyTop &&
                        bulletTop < enemyBottom) {
                        
                        enemy.health--;
                        bullets.splice(bIndex, 1);
                        
                        // Enhanced particles for hit
                        for (let i = 0; i < 15; i++) {
                            particles.push({
                                x: enemy.x,
                                y: enemy.y,
                                dx: (Math.random() - 0.5) * 8,
                                dy: (Math.random() - 0.5) * 8,
                                size: Math.random() * 4 + 2,
                                color: enemy.color,
                                life: 30
                            });
                        }
                        
                        if (enemy.health <= 0) {
                            score += enemy.points;
                            coins += Math.floor(enemy.points / 5); // Earn coins (1 coin per 5 points)
                            enemyKills++; // Increment kill count
                            
                            // Check for level up
                            checkLevelUp();
                            
                            // Massive explosion particles for death
                            for (let i = 0; i < 40; i++) {
                                const angle = (Math.PI * 2 * i) / 40;
                                const speed = Math.random() * 6 + 3;
                                particles.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    dx: Math.cos(angle) * speed,
                                    dy: Math.sin(angle) * speed,
                                    size: Math.random() * 5 + 2,
                                    color: enemy.color,
                                    life: 40
                                });
                            }
                            
                            // White flash particles
                            for (let i = 0; i < 20; i++) {
                                particles.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    dx: (Math.random() - 0.5) * 10,
                                    dy: (Math.random() - 0.5) * 10,
                                    size: Math.random() * 6 + 3,
                                    color: '#ffffff',
                                    life: 20
                                });
                            }
                            
                            spawnPowerup(enemy.x, enemy.y);
                            enemies.splice(eIndex, 1);
                        }
                        
                        break; // Exit inner loop after collision
                    }
                }
            }
            
            // Enemy bullets vs player
            for (let index = bullets.length - 1; index >= 0; index--) {
                const bullet = bullets[index];
                if (bullet.enemy) {
                    if (bullet.x > player.x - player.width / 2 &&
                        bullet.x < player.x + player.width / 2 &&
                        bullet.y > player.y - player.height / 2 &&
                        bullet.y < player.y + player.height / 2) {
                        
                        if (!shield) {
                            health -= 10;
                        }
                        bullets.splice(index, 1);
                    }
                }
            }
            
            // Enemies vs player
            for (let index = enemies.length - 1; index >= 0; index--) {
                const enemy = enemies[index];
                if (enemy.y + enemy.height / 2 > player.y - player.height / 2 &&
                    enemy.y - enemy.height / 2 < player.y + player.height / 2 &&
                    enemy.x + enemy.width / 2 > player.x - player.width / 2 &&
                    enemy.x - enemy.width / 2 < player.x + player.width / 2) {
                    
                    if (!shield) {
                        health -= 20;
                    }
                    enemies.splice(index, 1);
                }
                
                // Enemy escaped
                if (enemy.y > canvas.height) {
                    if (!shield) {
                        health -= 5;
                    }
                }
            }
            
            // Powerups vs player
            for (let index = powerups.length - 1; index >= 0; index--) {
                const powerup = powerups[index];
                if (powerup.y + powerup.height / 2 > player.y - player.height / 2 &&
                    powerup.y - powerup.height / 2 < player.y + player.height / 2 &&
                    powerup.x + powerup.width / 2 > player.x - player.width / 2 &&
                    powerup.x - powerup.width / 2 < player.x + player.width / 2) {
                    
                    activatePowerup(powerup.type);
                    powerups.splice(index, 1);
                }
            }
        }
        
        function activatePowerup(type) {
            // Auto-activate mode
            if (autoActivatePowerups) {
                applyPowerupEffect(type);
                return;
            }
            
            // Manual mode - store with stacking
            const existingIndex = storedPowerups.findIndex(p => p.type === type);
            if (existingIndex >= 0) {
                // Stack the powerup (increase count and double duration)
                storedPowerups[existingIndex].count++;
            } else if (storedPowerups.length < maxStoredPowerups) {
                // Add new powerup
                storedPowerups.push({ type: type, count: 1 });
            }
            updateStoredPowerupsDisplay();
        }
        
        function applyPowerupEffect(type) {
            switch(type) {
                case 'rapidfire':
                    rapidFire = true;
                    rapidFireTimer = 600; // 10 seconds
                    updatePowerupDisplay();
                    break;
                case 'shield':
                    shield = true;
                    shieldTimer = 480; // 8 seconds
                    updatePowerupDisplay();
                    break;
                case 'health':
                    health = Math.min(100, health + 30);
                    break;
                case 'bullets':
                    // Unlimited bullets for 10 seconds
                    maxBulletsInBurst = 999;
                    setTimeout(() => {
                        maxBulletsInBurst = 3;
                    }, 10000);
                    break;
            }
        }
        
        function usePowerup(index) {
            if (index >= storedPowerups.length) return;
            
            const powerup = storedPowerups[index];
            const count = powerup.count;
            
            // Apply effect with duration multiplied by count
            switch(powerup.type) {
                case 'rapidfire':
                    rapidFire = true;
                    rapidFireTimer = 600 * count; // 10 seconds √ó count
                    updatePowerupDisplay();
                    break;
                case 'shield':
                    shield = true;
                    shieldTimer = 480 * count; // 8 seconds √ó count
                    updatePowerupDisplay();
                    break;
                case 'health':
                    health = Math.min(100, health + (30 * count));
                    break;
                case 'bullets':
                    maxBulletsInBurst = 999;
                    setTimeout(() => {
                        maxBulletsInBurst = 3;
                    }, 10000 * count);
                    break;
            }
            
            storedPowerups.splice(index, 1);
            updateStoredPowerupsDisplay();
        }
        
        function useAllPowerups() {
            while (storedPowerups.length > 0) {
                usePowerup(0);
            }
        }
        
        function updateStoredPowerupsDisplay() {
            const container = document.getElementById('storedPowerupsContainer');
            container.innerHTML = '';
            
            storedPowerups.forEach((powerup, index) => {
                const badge = document.createElement('div');
                badge.className = 'stored-powerup-badge';
                badge.onclick = () => usePowerup(index);
                badge.style.position = 'relative';
                
                let icon, color;
                switch(powerup.type) {
                    case 'rapidfire':
                        icon = '‚ö°';
                        color = '#ff00ff';
                        break;
                    case 'shield':
                        icon = 'üõ°Ô∏è';
                        color = '#00ffff';
                        break;
                    case 'health':
                        icon = '‚ù§Ô∏è';
                        color = '#ff0000';
                        break;
                    case 'bullets':
                        icon = 'üî´';
                        color = '#ffaa00';
                        break;
                }
                
                badge.style.borderColor = color;
                badge.style.color = color;
                badge.textContent = icon;
                
                // Show count if stacked
                if (powerup.count > 1) {
                    const countBadge = document.createElement('span');
                    countBadge.style.position = 'absolute';
                    countBadge.style.top = '-5px';
                    countBadge.style.right = '-5px';
                    countBadge.style.background = color;
                    countBadge.style.color = '#000';
                    countBadge.style.borderRadius = '50%';
                    countBadge.style.width = '18px';
                    countBadge.style.height = '18px';
                    countBadge.style.display = 'flex';
                    countBadge.style.alignItems = 'center';
                    countBadge.style.justifyContent = 'center';
                    countBadge.style.fontSize = '10px';
                    countBadge.style.fontWeight = 'bold';
                    countBadge.textContent = 'x' + powerup.count;
                    badge.appendChild(countBadge);
                }
                
                container.appendChild(badge);
            });
        }
        
        function updatePowerupDisplay() {
            const container = document.getElementById('powerupContainer');
            container.innerHTML = '';
            
            if (rapidFire) {
                const badge = document.createElement('div');
                badge.className = 'powerup-badge';
                badge.style.borderColor = '#ff00ff';
                badge.style.color = '#ff00ff';
                badge.textContent = '‚ö° ÿ•ÿ∑ŸÑÿßŸÇ ÿ≥ÿ±Ÿäÿπ';
                container.appendChild(badge);
            }
            
            if (shield) {
                const badge = document.createElement('div');
                badge.className = 'powerup-badge';
                badge.style.borderColor = '#00ffff';
                badge.style.color = '#00ffff';
                badge.textContent = 'üõ°Ô∏è ÿØÿ±ÿπ';
                container.appendChild(badge);
            }
        }
        
        function updatePowerupTimers() {
            if (rapidFire) {
                rapidFireTimer--;
                if (rapidFireTimer <= 0) {
                    rapidFire = false;
                    updatePowerupDisplay();
                }
            }
            
            if (shield) {
                shieldTimer--;
                if (shieldTimer <= 0) {
                    shield = false;
                    updatePowerupDisplay();
                }
            }
        }
        
        function draw() {
            // Clear
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Stars
            stars.forEach(star => {
                ctx.fillStyle = `rgba(255, 255, 255, ${star.size / 2})`;
                ctx.fillRect(star.x, star.y, star.size, star.size);
            });
            
            // Player trail
            player.trail.forEach((point, index) => {
                const alpha = point.life / 10;
                ctx.fillStyle = `rgba(0, 255, 255, ${alpha * 0.3})`;
                ctx.beginPath();
                ctx.arc(point.x, point.y, 20, 0, Math.PI * 2);
                ctx.fill();
                point.life--;
            });
            
            // Player
            ctx.save();
            ctx.translate(player.x, player.y);
            
            if (shield) {
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, 35, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.fillStyle = player.color;
            ctx.shadowBlur = 20;
            ctx.shadowColor = player.color;
            ctx.beginPath();
            ctx.moveTo(0, -player.height / 2);
            ctx.lineTo(-player.width / 2, player.height / 2);
            ctx.lineTo(player.width / 2, player.height / 2);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
            
            // Draw allies
            drawAllies();
            
            // Bullets
            bullets.forEach(bullet => {
                ctx.fillStyle = bullet.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = bullet.color;
                ctx.fillRect(bullet.x - bullet.width / 2, bullet.y - bullet.height / 2, 
                           bullet.width, bullet.height);
            });
            
            // Enemies
            if (!bossActive) {
                enemies.forEach(enemy => {
                ctx.save();
                ctx.translate(enemy.x, enemy.y);
                
                // Draw spaceship shape
                ctx.fillStyle = enemy.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = enemy.color;
                
                // Main body (triangle pointing down)
                ctx.beginPath();
                ctx.moveTo(0, enemy.height / 2); // Bottom point
                ctx.lineTo(-enemy.width / 2, -enemy.height / 2); // Top left
                ctx.lineTo(enemy.width / 2, -enemy.height / 2); // Top right
                ctx.closePath();
                ctx.fill();
                
                // Wings
                ctx.fillStyle = ctx.fillStyle;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.moveTo(-enemy.width / 2, -enemy.height / 4);
                ctx.lineTo(-enemy.width * 0.8, 0);
                ctx.lineTo(-enemy.width / 2, enemy.height / 4);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(enemy.width / 2, -enemy.height / 4);
                ctx.lineTo(enemy.width * 0.8, 0);
                ctx.lineTo(enemy.width / 2, enemy.height / 4);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
                
                // Cockpit
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(0, -enemy.height / 4, enemy.width / 6, 0, Math.PI * 2);
                ctx.fill();
                
                // Engine glow
                ctx.fillStyle = enemy.color;
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.arc(0, enemy.height / 2, enemy.width / 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                
                ctx.restore();
                
                // Health bar for tanks
                if (enemy.type === 'tank' && enemy.health > 1) {
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(enemy.x - 20, enemy.y - enemy.height / 2 - 10, 40 * (enemy.health / 3), 4);
                }
            });
            }
            
            // Boss
            if (bossActive) {
                drawBoss();
            }
            
            // Powerups
            powerups.forEach(powerup => {
                let color;
                switch(powerup.type) {
                    case 'rapidfire': color = '#ff00ff'; break;
                    case 'shield': color = '#00ffff'; break;
                    case 'health': color = '#ff0000'; break;
                    case 'bullets': color = '#ffaa00'; break;
                }
                
                // Draw fading circles
                const lifePercent = powerup.lifetime / powerup.maxLifetime;
                for (let i = 0; i < 3; i++) {
                    const radius = 15 + i * 10;
                    const alpha = lifePercent * 0.3 * (1 - i * 0.3);
                    ctx.strokeStyle = color;
                    ctx.globalAlpha = alpha;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(powerup.x, powerup.y, radius + Math.sin(Date.now() / 200 + i) * 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
                
                // Draw powerup
                ctx.fillStyle = color;
                ctx.shadowBlur = 20;
                ctx.shadowColor = color;
                ctx.save();
                ctx.translate(powerup.x, powerup.y);
                ctx.rotate(Date.now() / 500);
                ctx.fillRect(-powerup.width / 2, -powerup.height / 2, 
                           powerup.width, powerup.height);
                ctx.restore();
            });
            
            // Particles
            particles.forEach(particle => {
                const alpha = particle.life / 40;
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = alpha;
                ctx.shadowBlur = 15;
                ctx.shadowColor = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }
        
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('coins').textContent = coins;
            const killsNeeded = 10; // Always 10 kills
            document.getElementById('level').textContent = level + ' (' + enemyKills + '/' + killsNeeded + ')';
            document.getElementById('health').textContent = Math.max(0, Math.floor(health)) + '% | ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿßÿ™: ' + livesRemaining;
            document.getElementById('energy').textContent = Math.floor(energy);
        }
        
        function checkLevelUp() {
            const killsNeeded = 10; // Always 10 kills per level
            if (enemyKills >= killsNeeded) {
                level++;
                enemyKills = 0; // Reset kills for next level
                
                // Check if it's a boss level (every 3 levels)
                if (level % 3 === 0) {
                    // Boss level!
                    levelTransition = true;
                    levelTransitionTimer = 180; // 3 seconds before boss
                    enemies = [];
                    bullets = bullets.filter(b => !b.enemy);
                    
                    setTimeout(() => {
                        spawnBoss();
                    }, 3000);
                } else {
                    // Normal level transition
                    levelTransition = true;
                    levelTransitionTimer = 120; // 2 seconds pause
                    enemies = [];
                    bullets = bullets.filter(b => !b.enemy);
                }
                
                // Every 5 levels, show bonus screen (if not boss level)
                if (level % 5 === 1 && level > 1 && level % 3 !== 0) {
                    gameRunning = false;
                    const bonusPoints = (level - 1) * 100;
                    score += bonusPoints;
                    health = 100;
                    energy = 100;
                    
                    document.getElementById('bonusLevel').textContent = level - 1;
                    document.getElementById('bonusPoints').textContent = bonusPoints;
                    document.getElementById('bonusScreen').style.display = 'block';
                } else if (level % 3 !== 0) {
                    health = Math.min(100, health + 20);
                    energy = 100;
                }
                
                // Show level up notification
                const container = document.getElementById('powerupContainer');
                const levelBadge = document.createElement('div');
                levelBadge.className = 'powerup-badge';
                levelBadge.style.borderColor = '#ffff00';
                levelBadge.style.color = '#ffff00';
                levelBadge.style.animation = 'pulse 0.5s';
                levelBadge.textContent = level % 3 === 0 ? 'üëë ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ®Ÿàÿ≥ ' + level + '! üëë' : 'üéâ ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ' + level + '!';
                container.appendChild(levelBadge);
                
                setTimeout(() => {
                    levelBadge.remove();
                }, 3000);
            }
        }
        
        function gameLoop() {
            if (!gameRunning && !gamePaused) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            if (gamePaused) {
                draw(); // Still draw when paused
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // Handle level transition
            if (levelTransition) {
                levelTransitionTimer--;
                if (levelTransitionTimer <= 0) {
                    levelTransition = false;
                }
            }
            
            updatePlayer();
            updateAllies(); // Update allies
            updateBullets();
            if (bossActive) {
                updateBoss();
            } else if (!levelTransition) {
                updateEnemies();
            }
            updatePowerups();
            updateParticles();
            updateStars();
            updatePowerupTimers();
            checkCollisions();
            draw();
            updateUI();
            
            // Spawn enemies (only if not in level transition and no boss)
            if (!levelTransition && !bossActive) {
                const spawnRate = 0.002 + level * 0.001; // Much fewer enemies
                if (Math.random() < spawnRate) {
                    spawnEnemy();
                }
            }
            
            // Check game over
            if (health <= 0) {
                gameOver();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        function showBossRewards() {
            gameRunning = false;
            
            // Generate 3 random rewards
            const rewardTypes = ['ally', 'powerup', 'powerup'];
            const rewards = [];
            
            for (let i = 0; i < 3; i++) {
                const type = rewardTypes[Math.floor(Math.random() * rewardTypes.length)];
                if (type === 'ally' && allies.length < maxAllies) {
                    rewards.push({
                        type: 'ally',
                        icon: 'üöÄ',
                        text: 'ŸÖŸÇÿßÿ™ŸÑ ÿ•ÿ∂ÿßŸÅŸä',
                        color: '#00ffff'
                    });
                } else {
                    const powerupTypes = ['rapidfire', 'shield', 'health', 'bullets'];
                    const pType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
                    let icon, text, color;
                    switch(pType) {
                        case 'rapidfire': icon = '‚ö°'; text = 'ÿ•ÿ∑ŸÑÿßŸÇ ÿ≥ÿ±Ÿäÿπ'; color = '#ff00ff'; break;
                        case 'shield': icon = 'üõ°Ô∏è'; text = 'ÿØÿ±ÿπ'; color = '#00ffff'; break;
                        case 'health': icon = '‚ù§Ô∏è'; text = 'ÿµÿ≠ÿ© +50'; color = '#ff0000'; break;
                        case 'bullets': icon = 'üî´'; text = 'ÿ∑ŸÑŸÇÿßÿ™ ÿ∫Ÿäÿ± ŸÖÿ≠ÿØŸàÿØÿ©'; color = '#ffaa00'; break;
                    }
                    rewards.push({type: 'powerup', powerupType: pType, icon, text, color});
                }
            }
            
            const container = document.getElementById('rewardOptions');
            container.innerHTML = '';
            
            rewards.forEach((reward, index) => {
                const btn = document.createElement('button');
                btn.className = 'control-btn';
                btn.style.width = '250px';
                btn.style.fontSize = '18px';
                btn.style.background = `linear-gradient(135deg, ${reward.color}, #000)`;
                btn.textContent = `${reward.icon} ${reward.text}`;
                btn.onclick = () => selectReward(reward);
                container.appendChild(btn);
            });
            
            document.getElementById('bossRewardsScreen').style.display = 'block';
        }
        
        function selectReward(reward) {
            if (reward.type === 'ally') {
                addAlly();
            } else {
                activatePowerup(reward.powerupType);
            }
            document.getElementById('bossRewardsScreen').style.display = 'none';
            gameRunning = true;
        }
        
        function addAlly() {
            if (allies.length >= maxAllies) return;
            
            const ally = {
                x: player.x + (allies.length - 1.5) * 60,
                y: player.y + 40,
                width: 30,
                height: 30,
                color: ['#ff00ff', '#00ff00', '#ffaa00', '#00ffff'][allies.length],
                shootTimer: 0
            };
            allies.push(ally);
        }
        
        function updateAllies() {
            allies.forEach((ally, index) => {
                // Follow player with slight offset
                const targetX = player.x + (index - (allies.length - 1) / 2) * 50;
                const targetY = player.y + 50;
                
                ally.x += (targetX - ally.x) * 0.1;
                ally.y += (targetY - ally.y) * 0.1;
                
                // Allies shoot automatically
                ally.shootTimer++;
                if (ally.shootTimer > 30) {
                    bullets.push({
                        x: ally.x,
                        y: ally.y,
                        width: 4,
                        height: 12,
                        speed: 10,
                        color: ally.color
                    });
                    ally.shootTimer = 0;
                }
            });
        }
        
        function drawAllies() {
            allies.forEach(ally => {
                ctx.save();
                ctx.translate(ally.x, ally.y);
                ctx.fillStyle = ally.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = ally.color;
                ctx.beginPath();
                ctx.moveTo(0, -ally.height / 2);
                ctx.lineTo(-ally.width / 2, ally.height / 2);
                ctx.lineTo(ally.width / 2, ally.height / 2);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            });
        }
        
        function gameOver() {
            gameRunning = false;
            stopShooting();
            
            livesRemaining--;
            
            if (livesRemaining <= 0) {
                // Full game over
                document.getElementById('finalScore').textContent = score;
                
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('highScore', highScore);
                }
                
                document.getElementById('highScore').textContent = highScore;
                document.getElementById('gameOver').style.display = 'block';
            } else {
                // Restart level with remaining lives
                setTimeout(() => {
                    health = 100;
                    energy = 100;
                    player.x = canvas.width / 2;
                    player.y = canvas.height - 80;
                    bullets = [];
                    enemies = [];
                    particles = [];
                    enemyKills = 0; // Restart kill count for this level
                    
                    // Reset boss if was fighting one
                    if (bossActive) {
                        bossActive = false;
                        boss = null;
                        // Re-spawn boss after a delay
                        setTimeout(() => {
                            spawnBoss();
                        }, 2000);
                    }
                    
                    gameRunning = true;
                    
                    // Show lives remaining
                    const container = document.getElementById('powerupContainer');
                    const livesBadge = document.createElement('div');
                    livesBadge.className = 'powerup-badge';
                    livesBadge.style.borderColor = '#ff0000';
                    livesBadge.style.color = '#ff0000';
                    livesBadge.textContent = 'üíî ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿßÿ™ ÿßŸÑŸÖÿ™ÿ®ŸÇŸäÿ©: ' + livesRemaining;
                    container.appendChild(livesBadge);
                    
                    setTimeout(() => {
                        livesBadge.remove();
                    }, 3000);
                }, 1000);
            }
        }
        
        function restartGame() {
            gameRunning = true;
            gamePaused = false;
            score = 0;
            coins = 0;
            level = 1;
            health = 100;
            energy = 100;
            enemyKills = 0;
            livesRemaining = 3;
            levelTransition = false;
            bossActive = false;
            boss = null;
            allies = []; // Reset allies
            
            resizeCanvas();
            player.x = canvas.width / 2;
            player.y = canvas.height - 80;
            player.dx = 0;
            player.dy = 0;
            
            bullets = [];
            enemies = [];
            particles = [];
            powerups = [];
            rapidFire = false;
            shield = false;
            shooting = false;
            storedPowerups = [];
            
            stopShooting();
            
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('bonusScreen').style.display = 'none';
            document.getElementById('bossRewardsScreen').style.display = 'none';
            document.getElementById('powerupIndicator').style.display = 'none';
            document.getElementById('powerupContainer').innerHTML = '';
            document.getElementById('storedPowerupsContainer').innerHTML = '';
            document.getElementById('pauseBtn').textContent = '‚è∏ ÿ•ŸäŸÇÿßŸÅ';
            gameLoop();
        }
        
        // Auto-shoot with burst limit
        let shootInterval;
        let bulletsInBurst = 0;
        let maxBulletsInBurst = 3; // Maximum 3 bullets per burst
        let burstCooldown = false;
        
        function startShooting() {
            if (shootInterval) return;
            bulletsInBurst = 0; // Reset burst counter
            burstCooldown = false;
            shoot(); // Shoot immediately
            shootInterval = setInterval(() => {
                if (gameRunning && !burstCooldown) {
                    shoot();
                }
            }, rapidFire ? 100 : 200);
        }
        
        function stopShooting() {
            if (shootInterval) {
                clearInterval(shootInterval);
                shootInterval = null;
            }
        }
        
        
        // Start game loop (but game won't run until start button is pressed)
        gameLoop();
    </script>
</body>
</html>
